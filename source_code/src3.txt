



let a: String = "Power";
let v: () = ();

let b: String = a;
let d: Number = 2;

let c: Number = -90 + -d;

let g: []String = ["Baba", "eja"];
let f: [][]String = [["Hello"], ["Dada"], g];

struct Adef {
    field1: Number,
    field2: Type2
}

struct Type2 {
    field1: String
}

let q: Type2 = Type2 {
    field1: "Powder"
};

let t: Adef = Adef {
    field1: 24,
    field2: q
};

//let (a: UIO, b: Number) = none();

let () = ();
let p: (Number, String) = none();

let t: Number = (90);

// check that when i do 
// let x = (Number);

// check if the x becomes a tuple of Number or a primary expression?

// monk func_main(a: Number, b: Adef) -> Number {
//     let x: Number = func_main(9, "Power");
// }

// monk func_type(c: None) -> (String, Number) {
//     let z: Number = func_type();
//     let w: Number = func_main(34);
// }


//let t: (Number) = (90);
let y: (Number, Number) = (90, 90);

let (a:Number, b: String) = (45, "Red");
let (d:Number, f: Number) = y;

let (g:Number) = 90;