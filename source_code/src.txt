// struct People {
//     name: String,
//     age: Number
// }


// monk create_person(name: String) {
//     let this_age = 19;
    
//     let new_person = People {
//         name: name,
//         age: this_age,
//         };
        
//         // return new_person; // i'm yet to do the return keyword
//     }
    
//     monk start() {
//     create_person("Hallo");

//     let second = 90;
// }

// monk main() {
    // must always have a type -- no inference

    // primary & array type to an expression(NUMBER)
    // let single: Number = 800 + 70; 
    // let single_array: []String = ["One", "Two"];
    // let array_type: [][]Number = [[90, 50], [60, 45]];

    // let string_type: String = "Power";

    // // tuple type to expression
    // // let (var1: String, var2: String) = (90, 20);

    // // struct type to expression
    // let struct_var: StructType = StructType {
    //     field1: 80,
    //     field2: 800,
    // };

    // /* ASSIGNMENTS */
    // singe = 50;
    // array_type = [90, 35];

    // (var1, var2) = (80, 40);
    // var1 += 900;
    // var2 -= 500;

    // struct_var = StructType {
    //     field1: 900,
    //     field2: 45
    // };

    // i realize that the operators also matters here. Some types
    // won't allow you to just add onto them y'know

    // for the tuple, i'll code it as multiple variable declarations!
// }



// monk main() {
//     let var1 = 90;
//     let var2 = func_call(var1);
// }

// monk func_call(val: Number) -> Number {
//     return val * 2;
// }

// Basically, i want to run tests to ensure that other code works even when i change stuff



monk main() {
    //let single: Number = 800 + 70; 
    //let single_array: []String = ["One", "Two"];
    //let array_type: [][]Number = [[90, 50], [60, 45]];

    //let string_type: String = "Power";

    // tuple type to expression
    //let (var1: String, var2: String) = (90 + 7 * 2, "Hello boys");

    let num: Number = 900;
    let str: String = "Funmi";

    let num2: Number = -80;
    let num3: Number = 90 + (36 + 45);

    // let str1: String = "Pop" + "Sola";

    let arr: [][]Number = [[90], [50]];

    // let num3: [][]Number = arr;

    let strc: MySttruct = MySttruct {
        field: 50,
        field2: ["Pow"]
    };

    let str1: Two = Two {
        this: strc
    };

    let str2: Two = Two {
        this : MySttruct {
            field: -1000,
            field2: ["YESSSS"]
        }
    };


    // it remains to do the function calls
    // let x = main();

    // and checking on assignments
}


struct MySttruct {
    field: Number,
    field2: []String
}

struct Five {
    field1: Two
}

struct Two {
    this: MySttruct
}
















let x: (Number, Number) = 90;

monk iop(x:Number, y:Number) -> (String, Number) {

}

monk test2() -> Number {

}

monk test3() -> []Number {

}

monk main() {
    // t();

    let (x: Number, y:Number) = iop();
    let (x: Number, y:Number) = (90, 90);

    let x: Number = iop();
}
    // let a: Num = (90);
    // let a: Num = (90 + 100);
    // let (x, y) = (90, 100);
    // let (t, v) = iop();
    // let (v, w) = kut;


    if parser.get_current_token() == Token::COMMA




let a: Number = (90 + 2);
let n: () = ();
let b: (Number) = (90);
let c: (Number, String) = (90, "Hello");
let d: ([]Number) = ([90]);
let e: [](Number, String) = ();

let (f: Number, g: String, p: PO) = (90, "KO", d);
let (f: Number, g: String, p: PO) = [90, 5];

let t: Number = abc();

let w: OOP = MyStruct {
    field1: 90,
    field2: 80
};




struct MyStruct {
    field1: Number
}

let a: MyStruct = MyStruct {
    field1: 90,
};

let b: MyStruct = a;

//let c: String = "Str";
//let b: Number = e;